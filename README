======================================================
= Simulation and Inference of Neuron Networks (SINN) =
=      Copyright (c) 2017-2019 Alexandre René        =
======================================================
=======
# Sinn: A library for simulation and inference for dynamical systems

## Motivation

Libraries like Theano and TensorFlow provide powerful capabilities for fitting models to data. However, they are most tailored to fitting neural networks – the implementation of the kinds of dynamic mechanistic models often found in physics or applied mathematics remains error-prone and labour-intensive. Sinn provides a set of high-level constructs designed to integrate well with lower-level optimization libraries.

## Features


Sinn was originally developed in order to infer a mesoscopic neuron model (René et al., in prepration) and stood for “Simulation and Inference of Neural Networks”.

## Features

- Automatic differentiation and C-compilation provided by Theano.

- Compatible with PyMC3

  Make your model probabilistic with a few extra lines of code, for easy implementation of Bayesian inference and Monte Carlo sampling.

- Use optimization library only when desired.

  No code change is required to run models with either Numpy or Theano – the single line `shim.load_theano()` suffices to load the optimization library.
  Since a pure Numpy model does not require compilation every time it is run, this allows you to first develop your model faster with more easily traceable errors, and then benefit from the C-acceleration and automatic differentiation by loading the optimization library.

- Data structures which map naturally to the mathematical models

  + `Axis`: Unit-aware structure for continuous quantities such as time, space, temperature…
  + `DataAxes`: combining *n*-dimensional data with *n* axes.
    A development goal is to allow easier translation to Pandas' analogous `DataFrame` (the main difference between a frame and an axis being that the latter is continuous by design)
  + `History`: A `DataAxes` instance where one axis is time.


- Dynamic programming, aka lazy evaluation.

    Data is computed only as needed. This allows you to specify functions as
    <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mtable class="m-equation-square" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
    	<mtr>
    		<mtd>
    			<mspace width="6.0em" />
    		</mtd>
    		<mtd columnalign="left">
    			<mtable class="m-aligned">
    				<mtr>
    					<mtd columnalign="right">
    						<msub>
    							<mi>x</mi>
    							<mi>k</mi>
    						</msub>
    					</mtd>
    					<mtd columnalign="left">
    						<mo>=</mo>
    						<mi>f</mi>
    						<mrow>
    							<mo form="prefix">(</mo>
    							<msub>
    								<mi>x</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo>,</mo>
    							<msub>
    								<mi>y</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo form="postfix">)</mo>
    						</mrow>
    					</mtd>
    				</mtr>
    				<mtr>
    					<mtd columnalign="right">
    						<msub>
    							<mi>y</mi>
    							<mi>k</mi>
    						</msub>
    					</mtd>
    					<mtd columnalign="left">
    						<mo>=</mo>
    						<mi>f</mi>
    						<mrow>
    							<mo form="prefix">(</mo>
    							<msub>
    								<mi>x</mi>
    								<mi>k</mi>
    							</msub>
    							<mo>,</mo>
    							<msub>
    								<mi>y</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo form="postfix">)</mo>
    						</mrow>
    					</mtd>
    				</mtr>
    			</mtable>
    		</mtd>
    	</mtr>
    </mtable>
    </math>
    and then compute either *x* or *y* at any point *k<sup>\*</sup>*, without worrying about circular dependencies between the two arrays[^1] and without unnecessary calculations for points beyond *k<sup>\*</sup>*.

[^1] Unless there is an actual circular dependency of course.

## Development status

At present Sinn is at a pre-alpha stage of development, with features are still being added. I consider the basic code structure to be stable, but will still make backwards-incompatible changes to enhance naming consistency. The core functionality I consider reliable – it underlies much of my PhD work (René et al., in preparation) and has seen daily use by myself for two years now. Nonetheless, users should still treat this library as any fallible tool and check that it performs as expected in their situation.


## Installation

- Create the virtual environment if required

  python3 -m venv --system-site-packages $HOME/usr/venv/sinn

  You can omit --system-site-packages if you install all dependencies (like
  SciPy) within the virtual environment.


- Activate the virtual environment

  source $HOME/usr/venv/sinn/bin/activate

- `cd` to the directory containing this file

- Install with

  pip install .

  As usual, if you want to be able to modify the code, add the `-e` flag to obtain a development installation.


Copyright (c) 2017-2019 Alexandre René
