======================================================
= Simulation and Inference of Neuron Networks (SINN) =
=      Copyright (c) 2017-2019 Alexandre René        =
======================================================


Sinn was originally developed in order to infer a mesoscopic neuron model (René et al., in prepration) and stood for “Simulation and Inference of Neural Networks”.

## Features

- Automatic differentiation and C-compilation provided by Theano.

- Compatible with PyMC3

  Make your model probabilistic with a few extra lines of code, for easy implementation of Bayesian inference and Monte Carlo sampling.

- Use optimization library only when desired.

  No code change is required to run models with either Numpy or Theano – the single line `shim.load_theano()` suffices to load the optimization library.
  Since a pure Numpy model does not require compilation every time it is run, this allows you to first develop your model faster with more easily traceable errors, and then benefit from the C-acceleration and automatic differentiation by loading the optimization library.

- Data structures which map naturally to the mathematical models

  + `Axis`: Unit-aware structure for continuous quantities such as time, space, temperature…
  + `DataAxes`: combining *n*-dimensional data with *n* axes.
    A development goal is to allow easier translation to Pandas' analogous `DataFrame` (the main difference between a frame and an axis being that the latter is continuous by design)
  + `History`: A `DataAxes` instance where one axis is time.


- Dynamic programming, aka lazy evaluation.

    Data is computed only as needed. This allows you to specify functions as
    <!-- begin MathToWeb -->
    <!-- (your LaTeX) \[\begin{aligned}
    x_k &= f(x_{k-1}, y_{k-1}) \\
    y_k &= g(x_{k}, y_{k-1}) \\
    z_k &= h(x_k)
    \end{aligned}\] -->
    <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mtable class="m-equation-square" displaystyle="true" style="display: block; margin-top: 1.0em; margin-bottom: 2.0em">
    	<mtr>
    		<mtd>
    			<mspace width="6.0em" />
    		</mtd>
    		<mtd columnalign="left">
    			<mtable class="m-aligned">
    				<mtr>
    					<mtd columnalign="right">
    						<msub>
    							<mi>x</mi>
    							<mi>k</mi>
    						</msub>
    					</mtd>
    					<mtd columnalign="left">
    						<mo>=</mo>
    						<mi>f</mi>
    						<mrow>
    							<mo form="prefix">(</mo>
    							<msub>
    								<mi>x</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo>,</mo>
    							<msub>
    								<mi>y</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo form="postfix">)</mo>
    						</mrow>
    					</mtd>
    				</mtr>
    				<mtr>
    					<mtd columnalign="right">
    						<msub>
    							<mi>y</mi>
    							<mi>k</mi>
    						</msub>
    					</mtd>
    					<mtd columnalign="left">
    						<mo>=</mo>
    						<mi>g</mi>
    						<mrow>
    							<mo form="prefix">(</mo>
    							<msub>
    								<mi>x</mi>
    								<mi>k</mi>
    							</msub>
    							<mo>,</mo>
    							<msub>
    								<mi>y</mi>
    								<mrow>
    									<mi>k</mi>
    									<mo>-</mo>
    									<mn>1</mn>
    								</mrow>
    							</msub>
    							<mo form="postfix">)</mo>
    						</mrow>
    					</mtd>
    				</mtr>
    				<mtr>
    					<mtd columnalign="right">
    						<msub>
    							<mi>z</mi>
    							<mi>k</mi>
    						</msub>
    					</mtd>
    					<mtd columnalign="left">
    						<mo>=</mo>
    						<mi>h</mi>
    						<mrow>
    							<mo form="prefix">(</mo>
    							<msub>
    								<mi>x</mi>
    								<mi>k</mi>
    							</msub>
    							<mo form="postfix">)</mo>
    						</mrow>
    					</mtd>
    				</mtr>
    			</mtable>
    		</mtd>
    	</mtr>
    </mtable>
    </math>
    <!-- end MathToWeb -->
    and then compute either *x*, *y* or *z* at any point *k<sup>\*</sup>*, without worrying about circular dependencies between the three arrays[^1], computing values of *x* or *y* twice and without unnecessary calculations for points beyond *k<sup>\*</sup>*.

[^1] Unless there is an actual circular dependency of course.

## Development status

At present Sinn is at a pre-alpha stage of development, with features are still being added. I consider the basic code structure to be stable, but will still make backwards-incompatible changes to enhance naming consistency. The core functionality I consider reliable – it underlies much of my PhD work (René et al., in preparation) and has seen daily use by myself for two years now. Nonetheless, users should still treat this library as any fallible tool and check that it performs as expected in their situation.


## Installation

- Create the virtual environment if required

  python3 -m venv --system-site-packages ~/usr/venv/mackelab

  You can omit --system-site-packages if you install all dependencies (like
  SciPy) within the virtual environment.


- Activate the virtual environment

  source ~/usr/venv/mackelab/bin/activate


- cd to the directory containing this file


- Install the code in "Development mode"

  pip install -e .
